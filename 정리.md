# 공부 내용 정리

## Microservice Architecture

### Microservice Architecture의 정의

- 비즈니스 도메인을 중심으로 서비스를 모델링하고 구현하는 아키텍처
- 도메인 서비스 간의 통신은 네트워크 기반의 HTTP API 또는 비동기 메시징 방식으로 이루어짐
- 각 도메인 서비스를 자체 Database를 가짐

### Microservice Architecture 전환을 고려해야 하는 시점

- 생존이 목표인 초기 스타트업에서 벗어나 비즈니스 규모가 어느정도 궤도에 오르는 시점
- monolithic 구조의 장점보다 단점이 부각되는 시점
  - 하나의 repository에 코드베이스가 개개인이 감당할 수 없는 수준으로 커짐
  - 이에 따라 코드 파악과 유지보수가 어려워짐
  - 구현과 테스트, 배포의 속도가 점점 느려지고 정기배포라는 정차가 생김
  - 모든 측면에서의 확장성이 떨어지게 됨

### Microservice Architecture의 장점과 단점

- 우버가 msa를 도입한 이유 -> 확장성 개선
  - 증가하는 트래픽 처리
  - 새로운 기능을 쉽게 추가
  - 조직의 성장에 쉽게 적응할 수 있는 아키텍처 적용
- 장점
  - 각각의 비즈니스 도메인별로 독립적인 서비스를 운영할 수 있다.
  - 빠른 구현과 배포가 가능해진다.
  - 팀의 책임과 자율성이 극대화된다.
- 단점
  - 네트워크 기반의 API 호출로 서비스가 구성되기 때문에 프로세스간 통신에 비해 느리고 복잡하다.
  - 일관된 트랜잭션과 데이터 정합성을 유지하기 어렵다.
  - 테스트와 장애추적, 모니터링 등이 쉽지 않다.

## 권장하는 구현 방식

### 개발 디자인 문서를 작성하자

- 서비스 목표, 설계, 제약, 사항 등을 미리 고려하여 시행 착오를 줄일 수 있다.
- 개발 디자인 문서를 기반으로 동료들의 피드백을 받아 더 나은 방향으로 진행할 수 있다.
- 인수인계시 서비스 파악에 도움이 될 수 있다.

### 테이블이 아닌 핵심 도메인 도출 먼저

- 테이블은 객체를 영속화하는 그릇 정도로 생각하자.
- 요구사항과 제약조건을 고려하여 핵심 도메인 객체 도출에 집중하고 테이블 구조는 추후에 고려해야 한다.

### 변수명, 메소드명에 신경을 쓰자

- 메소드명, 변수명은 가독성에 많은 영향을 준다.
- 현업에서 사용하는 보편적인 언어를 사용하자.
- 네이밍 규칙을 정하자.

### API 명세시 request와 response의 프로퍼티 값은 필수 값만 유지한다.

- 이는 REST API는 물론 특정 객체의 공개된 메소드도 포함한다.
- request 파라미터가 많다는 건 책임이 많다는 신호로 보고 분리를 고려하자.
- response에다 불필요한 응답을 포함하고 있으면 추후에 불필요한 내용을 response에서 제거하기는 어렵다.

### setter 최소화

- 필수값은 객체 생성시에 받도록하고 도메인 상태 변경시에는 setter가 아닌 적절한 이름을 가진 메소드를 생성해야 한다.
- 적절한 메소드 명을 가진 메소드로 추출하는게 도메인 정합성 유지와 가독성 측면에서 setter 보다 더 좋다.

### transaction의 사용 범위 설정을 신중히 결정하자.

- 비싼 리소스임으로 최대한 작은 범위로 잡아야 한다.
- transaction의 범위에 3rd party 서비스 호출이 포함되면 timeout 설정은 필수이다.
- 3rd party 서비스 호출이 너무 오래 걸린다면, transaction에 포함하지 않고 보상 트랜잭션등 다른 방법을 고려해야 한다.

### try-catch는 필요한 경우만 사용하자.

- 코드양이 늘어나 가독성에 영향을 줄 수 있음으로, exception 발생 후 별도의 작업이 필요한 경우만 사용하자.

### 객체 모델링시 꼭 필요한 상태만 선언하자.

- 도메인 관심을 가지는 정도로만 추상화한다.
- 지나친 세분화는 도메인 파악을 어렵게하고 구현을 복잡하게 한다.

### 테스트 코드를 작성하자.

- 코드 변경 후 테스트 코드를 통해 예상치 못한 버그를 찾을 수 있다.
- 개발자에 안정감을 주고, 빠르게 기능을 구현하는데 도움을 준다.

### 목표한 기능을 수행하는 코드가 우선이다.

- 비즈니스 가치를 적절한 시간안에 전달하는 것도 매우 중요한 가치이다.
- 너무 처음부터 완벽하게 하려고 하기보다는 기능을 먼저 구현 후 리팩토링을 거쳐 코드의 질을 높이는 방식으로 접근하는 것이 좋다.

### 무조건 정석대로 구현할 필요는 없다.

- 약속한 시점에 기능을 런칭하는 것은 매우 중요하다.
- 따라서 적절한 trade off가 필요하다. (시간 vs 품질)
- 하지만 중복코드와 하드코딩은 특정 시점에 반드시 정리해야 함을 전재로 선택해야 한다.

## 대체키에 대하여

### 식별자, PK

- DDD의 Entity 개념에서 고유한 식별자는 중요한 개념이다.
- Entity는 자신의 생명주기동안 형태와 내용이 급격하게 바뀔 수 있지만, 연속성은 유지해야 한다.
- 이렇게 변화하는 Entity를 추적하려면 식별성이 부여되어야 하고, 식별자는 해당 시스템 내에서 유일하고 변경되어서는 안된다.
- 보통 DBMS로 영속성을 관리하는 시스템에서의 Entity 식별자는 Table의 PK와 매핑되는 경우가 대부분이다.

### 대체키의 정의 필요성

- 이 강의에서는 Entity의 식별자와 동급의 의미를 가지는 추가 식별자 정도로 용어를 정의하고자 한다.
- Entity의 식별자는 외부에 오픈하거나 오용되지 않도록 주의하고, 식별자가 아닌 대체키를 오픈하는 것이 좋다.
- 예시
  1. 2020년 5월 특정 서비스의 실제 사례
     - BingInt 형태의 유저 아이디를 URL PATH로 사용하여 유저의 거래 내역을 노출하는 GET API가 있다고 하자.
     - 이런 경우, URL의 숫자만 조작하면 다른 이의 거래 내역을 손쉽게 볼 수 있게 된다.
     - 이슈 발생 후, 랜덤 스트링 형태의 대체키로 변환하여 API를 수정함
  2. 외부 연동 서비스
     - 외부 협력사와 자사 서비스 간에 상품 데이터 연동 과정에서 키 값을 시스템 내부의 PK로 사용했다고 가정하자.
     - 그렇게 되면 양사간의 데이터는 자사 시스템 내부의 PK로 강하게 묶이게 된다.
     - 이 후, 자사 시스템에서 데이터베이스를 MySQL에서 MongoDB 등으로 변경하게 되면 달라진 PK 체계로 인해 많은 공수가 발생할 수 있다.

### 구현

- 시스템 내부에서의 Entity 식별자는 Long 타입의 id를 사용하고, 외부에 오픈하여 사용할 때에는 대체키를 사용한다.
- 대체키는 String 기반의 token을 생성하고, unique index를 설정하여 사용한다.
- MySQL 기준으로 1천만건 이상으로 넘어가기 전까지는 random string으로 사용해도 조회 성능에 크게 이슈가 없고, 성능을 고려한다면 UUID를 rearranged하여 사용하는 것을 검토할 수 있다.
  - UUID에 시계열 정보가 있는데, 이 정보를 UUID 앞으로 변경하는 것.
  - 참고: https://www.percona.com/blog/2014/12/19/store-uuid-optimized-way/

## 응용 계층, 외부 인터페이스 계층 구현

### Facade 구현

- DDD에서 말하는 응용 계층의 정의는 다음과 같다.
  - 수행할 작업을 정의한다.
  - 도메인 객체가 문제를 해결하도록 지시한다.
  - 다른 애플리케이션 계층과 상호 작용을 한다.
  - 비즈니스 규칙은 포함하지 않으며, 작업을 조정하고, 다음 하위 계층에서 도메인 객체의 협력을 위해 업무를 위임한다.
  - 작업을 조정하기만하고, 도메인 상태를 가지면 안된다.
- 해당 강의에서 제안할 응용 계층의 구현은 아래와 같다.
  - 비즈니스 결정을 내리진 않지만, 수행할 작업을 정의해야 한다.
  - 따라서 주로 transaction으로 묶여야 하는 도메인 로직과 그 외 로직을 aggregation 하는 역할로 한정 짓는다.
  - 또한 네이밍은 Service와 구분짓기위해 Facade라는 접미사를 사용한다.
    - Facade 패턴은 다양한 외부 인터페이스를 하나의 인터페이스로 통합하는 개념으로 사용되지만, 해당 강의에서는 로직의 조합이라는 측면을 강조하기 위해 Facade를 사용한다.

### Controller 구현

- DDD에서 말하는 인터페이스 계층의 정의는 다음과 같다.
  - 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 책임을 진다.
  - 외부 인터페이스 구현 기술에 관계없이 도메인 계층 로직을 호출하고 이에 대한 결과를 반환하여 응답으로 제공한다.
- 해당 강의에서는 HTTP API를 사용하고 필요에 따라 메세지 기반의 비동기 통신을 사용한다.

## 로깅의 중요성

- 신규 서비스를 접하게 되면 가장 먼저 확인하는 것은 로깅에 대한 것이다.
  - 중앙화된 로깅이 구축되어 있는지
  - 로깅 시에 남기는 항목이 무엇인지
  - 에러 발생시 해당 로그를 통해 버그의 원인을 찾을 수 있는지
  - 로그 모니터링을 통해 적절한 시스템 알람이 전송되고 있는지
- 특히 API 레벨의 request, response로 로깅은 추후 리팩토링에 필수 항목이 될 수 있다.
  - 테스트 코드가 적절히 작성되지 않는 시스템 환경에서는 API의 request, response만이 시스템 개선을 가능하게 해준다.
  - 문서화된 스펙보다 정확한 것은 API의 request, response 로그이다.
- ELK + Kafka 스택 로그 구축은 생각보다 어렵지 않다.
  - 어떤 것을 사용하든지 시스템 전체를 파악하기 위한 로깅과 모니터링 수단은 갖춰야 한다.
  - 자체적인 구축이 어렵다면 로깅 및 애플리케이션 모니터링 서비스를 사용해도 좋다.
- 서비스를 이용하는 유저가 에러를 접하게 되면 개발팀은 이를 즉시 인지할 수 있어야 한다.

## Aggregate

### 개념

- 연관관계의 묶음이다.
- Root는 Aggregate 내부의 특정 하나의 엔티티
- Aggregate 밖에서는 Root와만 직접 통신이 가능하다.
- Aggregate 내부에서는 연관객체끼리 서로 통신이 가능하다.
- Root를 제외한 다른 Aggregate 엔티티는 대체키 속성이 필요 없다.
  - 외부와 통신하지 않기 때문

### 주문 도메인의 Aggregate

- Item (Root)
- OptionGroup
- Option

### Factory

- 도메인의 제약조건을 만족하면서 객체를 생성하는 요소

### Repository

- Factory에서 생성한 객체를 DB에 저장하는 요소
